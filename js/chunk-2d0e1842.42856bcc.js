(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0e1842"],{"7b89":function(n,e,t){"use strict";t.r(e),e["default"]='\n**知识点主要包括以下几个方面：**\n\n- 基本概念：`DOM`事件的级别\n\n> 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用`DOM2` ....”。\n\n\n- `DOM`事件模型、`DOM`事件流\n\n> 面试官如果问你“**DOM事件模型**”，你不一定知道怎么回事。其实说的就是**捕获和冒泡**。\n\n**DOM事件流**，指的是事件传递的**三个阶段**。\n\n- 描述`DOM`事件捕获的具体流程\n\n> 讲的是事件的传递顺序。参数为`false`（默认）、参数为`true`，各自代表事件在什么阶段触发。\n\n能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。\n\n- `Event`对象的常见应用（`Event`的常用`api`方法）\n\n> `DOM`事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，`Event`对象是非常重要的。\n\n**自定义事件（非常重要）**\n\n> 一般人可以讲出事件和注册事件，但是如果让你讲**自定义事件**，能知道的人，就更少了。\n\n**DOM事件的级别**\n\n> `DOM`事件的级别，准确来说，是**DOM标准**定义的级别。包括：\n\n**DOM0的写法：**\n\n```javascript\n  element.onclick = function () {\n\n  }\n```\n\n\n> 上面的代码是在 `js` 中的写法；如果要在`html`中写，写法是：在`onclick`属性中，加 `js` 语句。\n\n\n**DOM2的写法：**\n\n\n```javascript\n  element.addEventListener(\'click\', function () {\n\n  }, false);\n```\n\n>【重要】上面的第三参数中，**true**表示事件在**捕获阶段**触发，**false**表示事件在**冒泡阶段**触发（默认）。如果不写，则默认为false。\n\n\n**DOM3的写法：**\n\n\n```javascript\n    element.addEventListener(\'keyup\', function () {\n\n    }, false);\n```\n\n> `DOM3`中，增加了很多事件类型，比如鼠标事件、键盘事件等。\n\n> PS：为何事件没有`DOM1`的写法呢？因为，`DOM1`标准制定的时候，没有涉及与事件相关的内容。\n\n**总结**：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。\n\n**DOM事件模型**\n\n> `DOM`事件模型讲的就是**捕获和冒泡**，一般人都能回答出来。\n\n- 捕获：从上往下。\n- 冒泡：从下（目标元素）往上。\n\n**DOM事件流**\n\n> `DOM`事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。\n\n**完整的事件流，分三个阶段：**\n\n1. 捕获：从 `window` 对象传到 目标元素。\n2. 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。\n3. 冒泡：从**目标元素**传到 `Window` 对象。\n\n![](http://img.smyhvae.com/20180306_1058.png)\n\n![](http://img.smyhvae.com/20180204_1218.jpg)\n\n\n**描述DOM事件捕获的具体流程**\n\n> 很少有人能说完整。\n\n**捕获的流程**\n\n\n![](http://img.smyhvae.com/20180306_1103.png)\n\n**说明**：捕获阶段，事件依次传递的顺序是：`window` --\x3e `document` --\x3e `html`--\x3e `body` --\x3e 父元素、子元素、目标元素。\n\n- PS1：第一个接收到事件的对象是 **window**（有人会说`body`，有人会说`html`，这都是错误的）。\n- PS2：`JS`中涉及到`DOM`对象时，有两个对象最常用：`window`、`doucument`。它们俩也是最先获取到事件的。\n\n代码如下：\n\n```javascript\n    window.addEventListener("click", function () {\n        alert("捕获 window");\n    }, true);\n\n    document.addEventListener("click", function () {\n        alert("捕获 document");\n    }, true);\n\n    document.documentElement.addEventListener("click", function () {\n        alert("捕获 html");\n    }, true);\n\n    document.body.addEventListener("click", function () {\n        alert("捕获 body");\n    }, true);\n\n    fatherBox.addEventListener("click", function () {\n        alert("捕获 father");\n    }, true);\n\n    childBox.addEventListener("click", function () {\n        alert("捕获 child");\n    }, true);\n\n```\n\n\n**补充一个知识点：**\n\n> 在 `js`中：\n\n- 如果想获取 `body` 节点，方法是：`document.body`；\n- 但是，如果想获取 `html`节点，方法是`document.documentElement`。\n\n\n**冒泡的流程**\n\n> 与捕获的流程相反\n\n\n**Event对象的常见 api 方法**\n\n> 用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过`Event`对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：\n\n**方法一**\n\n```javascript\n    event.preventDefault();\n```\n\n- 解释：阻止默认事件。\n- 比如，已知`<a>`标签绑定了click事件，此时，如果给`<a>`设置了这个方法，就阻止了链接的默认跳转。\n\n**方法二：阻止冒泡**\n\n> 这个在业务中很常见。\n\n> 有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件`A`，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件`A`。这个时候，就要用到阻止冒泡了。\n\n\n> `w3c`的方法：（火狐、谷歌、`IE11`）\n\n```javascript\n    event.stopPropagation();\n```\n\n> `IE10`以下则是：\n\n```javascript\n  event.cancelBubble = true;\n```\n\n> 兼容代码如下：\n\n```javascript\n   box3.onclick = function (event) {\n\n        alert("child");\n\n        //阻止冒泡\n        event = event || window.event;\n\n        if (event && event.stopPropagation) {\n            event.stopPropagation();\n        } else {\n            event.cancelBubble = true;\n        }\n    }\n```\n\n> 上方代码中，我们对`box3`进行了阻止冒泡，产生的效果是：事件不会继续传递到 `father`、`grandfather`、`body`了。\n\n\n**方法三：设置事件优先级**\n\n\n```javascript\n    event.stopImmediatePropagation();\n```\n\n这个方法比较长，一般人没听说过。解释如下：\n\n> 比如说，我用`addEventListener`给某按钮同时注册了事件`A`、事件`B`。此时，如果我单击按钮，就会依次执行事件A和事件`B`。现在要求：单击按钮时，只执行事件A，不执行事件`B`。该怎么做呢？这是时候，就可以用到`stopImmediatePropagation`方法了。做法是：在事件A的响应函数中加入这句话。\n\n> 大家要记住 `event` 有这个方法。\n\n**属性4、属性5（事件委托中用到）**\n\n\n```javascript\n\n    event.currentTarget   //当前所绑定的事件对象。在事件委托中，指的是【父元素】。\n\n    event.target  //当前被点击的元素。在事件委托中，指的是【子元素】。\n\n```\n\n上面这两个属性，在事件委托中经常用到。\n\n\n> **总结**：上面这几项，非常重要，但是容易弄混淆。\n\n\n**自定义事件**\n\n> 自定义事件的代码如下：\n\n\n```javascript\n    var myEvent = new Event(\'clickTest\');\n    element.addEventListener(\'clickTest\', function () {\n        console.log(\'smyhvae\');\n    });\n\n  //元素注册事件\n    element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest\n\n```\n\n> 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：\n\n```javascript\n    var myEvent = new Event(\'clickTest\');\n\n    element.addEventListener(\'clickTest\', function () {\n        console.log(\'smyhvae\');\n    });\n\n    setTimeout(function () {\n        element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest\n    }, 1000);\n```\n\n'}}]);