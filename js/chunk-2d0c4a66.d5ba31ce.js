(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0c4a66"],{"3c77":function(n,e,t){"use strict";t.r(e),e["default"]='\n什么是mvvm？\n---\n\n> MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象\n\n- 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。\n- ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理\n\nvue的优点是什么？\n---\n\n- 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变\n- 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑\n- 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写\n\n\n请详细说下你对vue生命周期的理解\n---\n\n> 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后\n\n\n- 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有\n- 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。\n- 更新前/后：当data变化时，会触发beforeUpdate和updated方法\n- 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\n\n组件之间的传值？\n---\n\n**父组件与子组件传值**\n\n```\n//父组件通过标签上面定义传值\n<template>\n    <Main :obj="data"></Main>\n</template>\n<script>\n    //引入子组件\n    import Main form "./main"\n    \n    exprot default{\n        name:"parent",\n        data(){\n            return {\n                data:"我要向子组件传递数据"\n            }\n        },\n        //初始化组件\n        components:{\n            Main\n        }\n    }\n<\/script>\n\n\n//子组件通过props方法接受数据\n\n<template>\n    <div>{{data}}</div>\n</template>\n<script>\n    exprot default{\n        name:"son",\n        //接受父组件传值\n        props:["data"]\n    }\n<\/script>\n\n```\n\n**子组件向父组件传递数据**\n\n```\n//子组件通过$emit方法传递参数\n<template>\n   <div v-on:click="events"></div>\n</template>\n<script>\n    //引入子组件\n    import Main form "./main"\n    \n    exprot default{\n        methods:{\n            events:function(){\n                \n            }\n        }\n    }\n<\/script>\n\n\n//\n\n<template>\n    <div>{{data}}</div>\n</template>\n<script>\n    exprot default{\n        name:"son",\n        //接受父组件传值\n        props:["data"]\n    }\n<\/script>\n\n```\n\n路由之间跳转？\n---\n\n**声明式（标签跳转）**\n\n```\n<router-link :to="index">\n```\n\n**编程式（ js跳转）**\n\n```\nrouter.push(\'index\')\n```\n\nvuex是什么？怎么使用？哪种功能场景使用它？\n---\n\n> vue框架中状态管理。在main.js引入store，注入。新建了一个目录`store`，….. `export` 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\n\n实现 Vue SSR\n---\n\n![](http://7xq6al.com1.z0.glb.clouddn.com/vue-ssr.jpg)\n\n**其基本实现原理**\n\n- app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。\n- webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。\n- 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。\n- 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 `window.__INITIAL_STATE__ `发送到客户端\n\n\n> Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的\n\n\n- `Vue SSR `需要做的事多点（输出完整 HTML），除了` complier -> vnode`，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。\n相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点\n\nVue 组件 data 为什么必须是函数\n---\n\n- 每个组件都是 Vue 的实例。\n- 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他\n\nVue computed 实现\n---\n\n- 建立与其他属性（如：data、 Store）的联系；\n- 属性改变后，通知计算属性重新计算\n\n> 实现时，主要如下\n\n- 初始化 data， 使用 `Object.defineProperty` 把这些属性全部转为 `getter/setter`。\n- 初始化 `computed`, 遍历 `computed` 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。\n- `Object.defineProperty getter` 依赖收集。用于依赖发生变化时，触发属性重新计算。\n- 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集\n\n\nVue complier 实现\n---\n\n- 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。\n- 总的来说，Vue complier 是将 template 转化成一个 render 字符串。\n\n> 可以简单理解成以下步骤：\n\n- parse 过程，将 template 利用正则转化成 AST 抽象语法树。\n- optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。\n- generate 过程，生成 render 字符串\n\n怎么快速定位哪个组件出现性能问题\n---\n\n> 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题\n'}}]);