(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d20eb64"],{b110:function(n,e,t){"use strict";t.r(e),e["default"]="\nMVVM\n---\n\n**MVVM 由以下三个内容组成**\n\n- `View`：界面\n- `Model`：数据模型\n- `ViewModel`：作为桥梁负责沟通 `View` 和 `Model`\n\n> - 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合\n> - 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel\n\n- 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持\n\n**脏数据检测**\n\n- 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次\n- 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数\n\n**数据劫持**\n\n- `Vue` 内部使用了 `Obeject.defineProperty()` 来实现双向绑定，通过这个函数可以监听到 `set` 和 `get `的事件\n\n```javascript\nvar data = { name: 'yck' }\nobserve(data)\nlet name = data.name // -> get value\ndata.name = 'yyy' // -> change value\n\nfunction observe(obj) {\n  // 判断类型\n  if (!obj || typeof obj !== 'object') {\n    return\n  }\n  Object.keys(data).forEach(key => {\n    defineReactive(data, key, data[key])\n  })\n}\n\nfunction defineReactive(obj, key, val) {\n  // 递归子属性\n  observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      console.log('get value')\n      return val\n    },\n    set: function reactiveSetter(newVal) {\n      console.log('change value')\n      val = newVal\n    }\n  })\n}\n```\n\n> 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅\n\n```html\n<div>\n    {{name}}\n</div>\n```\n\n> 在解析如上模板代码时，遇到 `{{name}}` 就会给属性 `name` 添加发布订阅\n\n\n```javascript\n// 通过 Dep 解耦\nclass Dep {\n  constructor() {\n    this.subs = []\n  }\n  addSub(sub) {\n    // sub 是 Watcher 实例\n    this.subs.push(sub)\n  }\n  notify() {\n    this.subs.forEach(sub => {\n      sub.update()\n    })\n  }\n}\n// 全局属性，通过该属性配置 Watcher\nDep.target = null\n\nfunction update(value) {\n  document.querySelector('div').innerText = value\n}\n\nclass Watcher {\n  constructor(obj, key, cb) {\n    // 将 Dep.target 指向自己\n    // 然后触发属性的 getter 添加监听\n    // 最后将 Dep.target 置空\n    Dep.target = this\n    this.cb = cb\n    this.obj = obj\n    this.key = key\n    this.value = obj[key]\n    Dep.target = null\n  }\n  update() {\n    // 获得新值\n    this.value = this.obj[this.key]\n    // 调用 update 方法更新 Dom\n    this.cb(this.value)\n  }\n}\nvar data = { name: 'yck' }\nobserve(data)\n// 模拟解析到 `{{name}}` 触发的操作\nnew Watcher(data, 'name', update)\n// update Dom innerText\ndata.name = 'yyy' \n```\n\n> 接下来,对 defineReactive 函数进行改造\n\n```javascript\nfunction defineReactive(obj, key, val) {\n  // 递归子属性\n  observe(val)\n  let dp = new Dep()\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      console.log('get value')\n      // 将 Watcher 添加到订阅\n      if (Dep.target) {\n        dp.addSub(Dep.target)\n      }\n      return val\n    },\n    set: function reactiveSetter(newVal) {\n      console.log('change value')\n      val = newVal\n      // 执行 watcher 的 update 方法\n      dp.notify()\n    }\n  })\n}\n```\n\n> 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加\n\n**Proxy 与 Obeject.defineProperty 对比**\n\n- `Obeject.defineProperty` 虽然已经能够实现双向绑定了，但是他还是有缺陷的。\n  - 只能对属性进行数据劫持，所以需要深度遍历整个对象\n  - 对于数组不能监听到数据的变化\n  \n> 虽然 `Vue` 中确实能检测到数组数据的变化，但是其实是使用了 `hack` 的办法，并且也是有缺陷的\n"}}]);